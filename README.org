Visualization for WebPPL. [[http://probmods.github.io/webppl-viz/][Demo]]

* Dependencies

- node.js (v4 or later)
- webppl (0.9.2-b0139d4 or later)
- Cairo (see [[https://github.com/Automattic/node-canvas/#installation][instructions for your operating system]])
- (/optional/) webppl-editor (1.0.5 or later)

TODO: refactor this into setup for browser versus setup for command line

* Setup

#+BEGIN_SRC sh
npm install --prefix ~/.webppl probmods/webppl-viz
#+END_SRC

To use on the command line, you need require =webppl-viz= as a
[[http://docs.webppl.org/en/master/packages.html#webppl-packages][WebPPL
package]]. Example: =webppl foo.wppl --require webppl-viz=

To include =webppl-viz= in a browser, include webppl-viz.js and
webppl-viz.css on your webpage. You can get pre-compiled versions of
these at TODO: link to GH releases. To build these yourself, run
=grunt bundle=.

* Basic usage

The =viz()= function visualizes two kinds of data: WebPPL
/distributions/ and /data frames/.

A data frame is an array of objects that all have the same keys (i.e.,
they have the same /schema/). For example:

#+BEGIN_SRC js
viz([{country: 'usa', populationRank: 6, gdp: 12.5435},
     {country: 'mex', populationRank: 10, gdp: 12.5435},
     {country: 'can', populationRank: 9, gdp: 12321.4}])
#+END_SRC

Distribution elements do not need to be objects with keys, although this
is recommended:

#+BEGIN_SRC js
viz(MH(function() { return          beta(2,1) }),   5) // okay
viz(MH(function() { return {weight: beta(2,1) } }), 5) // better
#+END_SRC

=viz= tries to automatically guess a useful graph. If you'd like to
If you want a custom graph, you can pass an additional options argument.

* Customizing graphs

we use vega-lite.
distribution is converted to a dataframe

** Disabling / changing smoothing for continuous distributions

By default, =viz()= smooths any continuous components in WebPPL distributions using density estimation with a Gaussian kernel.

To disable this and view the unsmoothed distribution, set the =transform= option to be false:

#+BEGIN_SRC js
viz(MH(function() { return {weight: beta(2,1) } }),
    {transform: false})
#+END_SRC

You can use a custom transformation function by passing in a function (note -- passing in a function you have defined in WebPPL will not work, because WebPPL transforms function methods at compile time. You need to pass in a reference to a JavaScript function).

You can view log probabilities instead of probabilities if you set =transform= to be src_js{'log'}

#+BEGIN_SRC js
viz(MH(function() { return {weight: beta(2,1) } }),
    {transform: 'log'})
#+END_SRC

** Output size and format

#+BEGIN_SRC js
viz(d,
    {width: 100,
     height: 200,
     format: 'svg' // can also use png
    })
#+END_SRC

** Changing variable types

viz chooses a graph using the /types/ of variables in your data --
nominal (e.g., "usa"), ordinal (e.g., 6), or quantitative (e.g.,
12.5435). viz guesses the type of each variable using heuristics:

- strings are considered nominal
- booleans and integer numbers are considered ordinal
- non-integer numbers are considered quantitative

Sometimes, you might want to override these heuristics. You can do this
by changing the type of a variable:

#+BEGIN_SRC js
viz([{country: 'usa', populationRank: 6, gdp: 12.5435},
     {country: 'mex', populationRank: 10, gdp: 12.5435},
     {country: 'can', populationRank: 9, gdp: 12321.4}],
    {fields: {populationRank: {type: 'quantitative'}}})
#+END_SRC

Here, we are treating =populationRank= as a continuous variable rather
than a discrete one.

** Changing graph types

** Flipping bar graph

by default, bar graphs are displayed horizontally (it's a more efficient use of space on the screen). but if you wanted to flip the orientation, you can do:

#+BEGIN_SRC js
viz(MH(function() { return {success: flip(0.5)}}, 10),
    {fields: {success:  {display: 'x'},
              __prob__: {display: 'y'}
    }})
#+END_SRC

here, we are telling =viz= to map the =__prob__= field to the y
dimension and the =success= field to the x dimension.

** setting bounds of variables

#+BEGIN_SRC js
viz(MH(function() { return {dollars: Math.round(beta(3,1) * 1000) } }, 100),
    {fields: {dollars: {scale: {domain: [0, 100]}}}})
#+END_SRC

** adjust angle of axis tick labels

#+BEGIN_SRC js
viz(MH(function() {return {word: uniformDraw(['prolixity','verbosity',
                                             'long-windedness','pleonastically'])}}, 20),
    {fields: {word: {axis: {labelAngle: 45}}}})
#+END_SRC

** aggregating data

* open questions

clearly distinguish between transforms and visualization
- but offer shortcuts for common combinations, like heatMap and densityCurve
- would 2d density estimator work on a crr distribution?
  - generalize to work with any number of non-r dimensions?
- idea: add a smooth argument that does smoothing by default but can be turned off.


names of vega marks are unintuitive (e.g., "text" for heat map, "line" for density)
- further mitigate by adding aliases ("table" -> "text")

raw data versus aggregate: point versus line?

handling thorny base Distributions:
- Poisson (ordinal but no support() method)
- Gaussian (isContinuous; no support() method)
- Beta (isContinuous; has support())
- Dirichlet (isContinuous; distribution over tensors)
